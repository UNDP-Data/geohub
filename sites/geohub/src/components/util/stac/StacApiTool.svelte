<script lang="ts">
	import type {
		DatasetFeature,
		Layer,
		LayerCreationInfo,
		RasterAlgorithm,
		StacAsset
	} from '$lib/types';
	import { FieldControl, Notification } from '@undp-data/svelte-undp-components';
	import { Loader } from '@undp-data/svelte-undp-design';
	import StacApiExplorer from '$components/util/stac/StacApiExplorer.svelte';
	import { generateHashKey } from '$lib/helper';
	import { RasterTileData } from '$lib/RasterTileData';
	import { createEventDispatcher } from 'svelte';

	export let selectedTool: { algorithmId: string; algorithm: RasterAlgorithm };
	export let dataset: DatasetFeature;

	let assetList: string[];
	let errorMessage = '';
	let isAdding = false;
	let selectedAssets: { [key: number]: StacAsset } = {};
	let selectedItem = undefined;
	// let hasTools: boolean = true;
	const itemsUrl = dataset.properties.url;
	let stacId: string = dataset.properties.tags.find((t) => t.key === 'stac')?.value;
	let collection: string = dataset.properties.tags.find((t) => t.key === 'collection')?.value;
	let itemJSON;
	const dispatch = createEventDispatcher();
	export const ALGORITHM_TAG_KEY = 'algorithm';

	const initialize = async () => {
		const itemsRes = await fetch(itemsUrl);
		const items = await itemsRes.json();
		const assets = items.features[0].assets;
		if (Object.keys(assets).length > 0) {
			assetList = Object.keys(assets).filter(
				(key) => assets[key].type.indexOf('image/tiff; application=geotiff') !== -1
			);
		}
	};

	const isAssetDuplicated = () => {
		const assetCount: { [key: string]: number } = {};
		Object.keys(selectedAssets).forEach((key) => {
			const value = selectedAssets[key];
			if (!value) return;
			if (!assetCount[value]) {
				assetCount[value] = 0;
			}
			assetCount[value] += 1;
		});
		return Object.keys(assetCount).filter((key) => assetCount[key] > 1).length > 0;
	};

	const listOfbands = (nbands: number) => {
		const list = [];
		for (let i = 1; i <= nbands; i++) {
			list.push(i);
		}
		return list;
	};

	const addToMap = async () => {
		try {
			isAdding = true;
			errorMessage = '';
			const urls = Object.keys(selectedAssets).map(
				(key) => `url=${encodeURIComponent(itemJSON['assets'][selectedAssets[key]].href)}`
			);
			let vrtUrl = dataset.properties.links.find((l) => l.rel === 'vrt')?.href;
			if (!vrtUrl) return;
			vrtUrl = `${vrtUrl.indexOf('localhost') === -1 ? vrtUrl : '/vrt'}?${urls.join('&')}`;
			const algorithmName = selectedTool.algorithm.title ?? selectedTool.algorithmId;
			let feature: DatasetFeature = JSON.parse(JSON.stringify(dataset));
			feature.properties.url = vrtUrl;
			feature.properties.id = generateHashKey(vrtUrl);
			feature.properties.is_raster = true;
			feature.properties.name = `${feature.properties.name} (${algorithmName})`;
			let description = `${feature.properties.description}<br>The result was generated by ${algorithmName} tool. The result was computed from the following assets: `;
			const assetsDescriptions = Object.keys(selectedAssets).map(
				(key, index) =>
					` - Band ${index + 1}: [${itemJSON['assets'][selectedAssets[key]].title}](${itemJSON['assets'][selectedAssets[key]].href})`
			);
			description = `${description}<br>${assetsDescriptions.join('<br>')}`;
			feature.properties.description = description;
			feature.properties.links?.forEach((link) => {
				const newLink = new URL(link.href);
				if (newLink.searchParams.get('url')) {
					newLink.searchParams.set('url', vrtUrl);
					link.href = newLink.href;
				}
			});

			const assetTags = Object.keys(selectedAssets).map((name) => {
				return { key: 'asset', value: itemJSON['assets'][selectedAssets[name]].href };
			});
			feature.properties.tags = [
				{ key: 'type', value: 'api' },
				...feature.properties.tags,
				...assetTags,
				{
					key: ALGORITHM_TAG_KEY,
					value: selectedTool.algorithmId
				}
			];

			console.log(feature);
			const rasterTile = new RasterTileData(feature);
			// set colormap name if it is available in algorithm metadata
			const colormap_name = selectedTool.algorithm.outputs.colormap_name ?? undefined;

			const data: LayerCreationInfo & { geohubLayer?: Layer } = await rasterTile.add(
				undefined,
				undefined,
				colormap_name,
				selectedTool.algorithmId
			);
			// revert tags to original
			feature.properties.tags = JSON.parse(JSON.stringify(dataset.properties.tags));
			feature.properties.tags = [
				...feature.properties.tags,
				...assetTags,
				{
					key: ALGORITHM_TAG_KEY,
					value: selectedTool.algorithmId
				}
			];

			// set unit if it is available in algorithm metadata
			if (selectedTool.algorithm.outputs.unit) {
				feature.properties.tags.push({
					key: 'unit',
					value: selectedTool.algorithm.outputs.unit
				});
			}

			data.geohubLayer = {
				id: data.layer.id,
				name: feature.properties.name,
				info: data.metadata,
				dataset: feature,
				colorMapName: data.colormap_name
			};

			dispatch('dataAdded', {
				layers: [data]
			});
		} catch (err) {
			console.error(err);
			errorMessage = err.message;
		} finally {
			isAdding = false;
		}
	};

	const getThumbnail = async (selectedItem) => {
		const res = await fetch(`${itemsUrl}/${selectedItem.id}`);
		itemJSON = await res.json();
		const thumbNailUrl = itemJSON.links.find((l) => l.rel === 'thumbnail')?.href;
		if (thumbNailUrl) {
			return thumbNailUrl;
		} else {
			return;
		}
	};
</script>

{#if dataset}
	{#await initialize()}
		<div class="is-flex is-justify-content-center">
			<Loader size="medium" />
		</div>
		<!-- eslint-disable-next-line @typescript-eslint/no-unused-vars -->
	{:then _}
		{#key selectedItem}
			{#if selectedItem}
				{#await getThumbnail(selectedItem)}
					<div class="is-flex is-justify-content-center">
						<Loader size="medium" />
					</div>
				{:then thumbnail}
					<div class="columns">
						<div class="column">
							<FieldControl title="Select input data" showHelpPopup={false}>
								<div slot="control">
									{#if selectedTool.algorithm.inputs.bands}
										{#each selectedTool.algorithm.inputs.bands as band, index}
											<div class="field">
												<!-- svelte-ignore a11y-label-has-associated-control -->
												<label class="label"
													>{band.title} ({band.required ? 'Required' : 'Optional'})</label
												>
												<div class="control">
													<div class="select">
														<select bind:value={selectedAssets[index]}>
															{#each assetList as asset}
																<option value={asset}>{asset}</option>
															{/each}
														</select>
													</div>
												</div>
											</div>
										{/each}
									{:else}
										{#each listOfbands(selectedTool.algorithm.inputs.nbands) as bandNo, index}
											<div class="field">
												<!-- svelte-ignore a11y-label-has-associated-control -->
												<label class="label">Input Band {bandNo}</label>
												<div class="control">
													<div class="select">
														<select bind:value={selectedAssets[index]}>
															{#each assetList as asset}
																<option value={asset}>{asset}</option>
															{/each}
														</select>
													</div>
												</div>
											</div>
										{/each}
									{/if}
								</div>
								<div slot="help">{selectedTool.algorithm.description}</div>
							</FieldControl>
						</div>
						<div class="column">
							{#if thumbnail}
								<div class="column is-6">
									<img src={thumbnail} alt="Thumbnail" />
								</div>
							{/if}
						</div>
					</div>
				{/await}
			{:else}
				<StacApiExplorer bind:selectedItem {stacId} {collection} bind:selectedTool bind:dataset />
			{/if}

			{#key selectedAssets}
				{#if Object.keys(selectedAssets).length > 0}
					{@const isDuplicated = isAssetDuplicated()}
					{@const isAllSelected =
						selectedTool.algorithm.inputs.nbands ===
							Object.keys(selectedAssets).filter((key) => selectedAssets[key] !== undefined)
								.length ||
						selectedTool.algorithm.inputs.bands?.length ===
							Object.keys(selectedAssets).filter((key) => selectedAssets[key] !== undefined).length}
					{#if isDuplicated || errorMessage || !isAllSelected}
						<Notification type="danger" showCloseButton={false}>
							{#if isDuplicated}
								Same item was selected several times. Please assign different date and item each
								input band.
							{:else if !isAllSelected}
								Please select an asset item for each input band.
							{:else if errorMessage}
								The server returned an error ({errorMessage}). Please try again later.
							{/if}
						</Notification>
					{/if}

					<button
						class="button is-primary is-uppercase has-text-weight-bold mt-2 {isAdding
							? 'is-loading'
							: ''}"
						disabled={isDuplicated || !isAllSelected || isAdding}
						on:click={addToMap}>Add to map</button
					>
				{/if}
			{/key}
		{/key}
	{/await}
{/if}
