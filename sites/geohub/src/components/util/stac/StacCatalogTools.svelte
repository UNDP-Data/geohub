<script context="module" lang="ts">
	interface ToolBreadcrumb extends BreadcrumbPage {
		type: 'index' | 'tool';
	}
</script>

<script lang="ts">
	import RasterAlgorithmExplorer, {
		ALGORITHM_TAG_KEY
	} from '$components/maplibre/raster/RasterAlgorithmExplorer.svelte';
	import { RasterTileData } from '$lib/RasterTileData';
	import { generateHashKey } from '$lib/helper';
	import type {
		DatasetFeature,
		Layer,
		LayerCreationInfo,
		RasterAlgorithm,
		StacAsset,
		StacCollection,
		Tag
	} from '$lib/types';
	import {
		Breadcrumbs,
		FieldControl,
		Notification,
		type BreadcrumbPage
	} from '@undp-data/svelte-undp-components';
	import { createEventDispatcher } from 'svelte';
	import StacCatalogDatePicker from './StacCatalogDatePicker.svelte';

	const dispatch = createEventDispatcher();

	export let collectionUrl: string;
	export let collection: StacCollection;
	export let dataset: DatasetFeature = undefined;

	let isAdding = false;
	let errorMessage = '';

	let selectedTool: { algorithmId: string; algorithm: RasterAlgorithm };

	let selectedAssets: { [key: number]: StacAsset } = {};

	let selectedDates: { [key: number]: Date } = {};

	let breadcrumbs: ToolBreadcrumb[] = [
		{
			title: 'Tool Menu',
			type: 'index'
		}
	];

	const handleToolSelected = (e) => {
		const tag: Tag = e.detail.tag;
		const algorithm: RasterAlgorithm = e.detail.algorithm;
		selectedTool = {
			algorithmId: tag.value,
			algorithm
		};
		selectedAssets = {};
		breadcrumbs = [
			...breadcrumbs,
			{
				title: algorithm.title ?? selectedTool.algorithmId,
				type: 'tool'
			}
		];
	};

	const handleBreadcrumbClicked = (e) => {
		const page: ToolBreadcrumb = e.detail;
		if (breadcrumbs?.length > 0) {
			const pageIndex = breadcrumbs.findIndex((p) => p.title === page.title);
			breadcrumbs = [...breadcrumbs.slice(0, pageIndex + 1)];
		}
	};

	const handleDateSelected = (date: Date, index: number) => {
		const isFirstBand =
			Object.keys(selectedAssets)
				.map((k) => k.toString())
				.findIndex((k) => k === index.toString()) === 0;
		if (!isFirstBand) return;
		// if first band date is changed, update other later bands
		Object.keys(selectedAssets)
			.filter((k) => k !== index.toString())
			.forEach((k) => {
				selectedAssets[k] = undefined;
				selectedDates[k] = new Date(date);
			});
	};

	const listOfbands = (nbands: number) => {
		const list = [];
		for (let i = 1; i <= nbands; i++) {
			list.push(i);
		}
		return list;
	};

	const isAssetDuplicated = () => {
		const assetCount: { [key: string]: number } = {};
		Object.keys(selectedAssets).forEach((key) => {
			const value = selectedAssets[key];
			if (!value) return;
			if (!assetCount[value.href]) {
				assetCount[value.href] = 0;
			}
			assetCount[value.href] += 1;
		});
		return Object.keys(assetCount).filter((key) => assetCount[key] > 1).length > 0;
	};

	const handleClickAdd = async () => {
		try {
			isAdding = true;
			errorMessage = '';

			const urls = Object.keys(selectedAssets).map(
				(key) => `url=${encodeURIComponent(selectedAssets[key].href)}`
			);
			let vrtUrl = dataset.properties.links.find((l) => l.rel === 'vrt')?.href;
			if (!vrtUrl) return;
			vrtUrl = `${vrtUrl.indexOf('localhost') === -1 ? vrtUrl : '/vrt'}?${urls.join('&')}`;
			const algorithmName = selectedTool.algorithm.title ?? selectedTool.algorithmId;

			let feature: DatasetFeature = JSON.parse(JSON.stringify(dataset));
			feature.properties.url = vrtUrl;
			feature.properties.id = generateHashKey(vrtUrl);
			feature.properties.name = `${feature.properties.name} (${algorithmName})`;
			let description = `${feature.properties.description}<br>The result was generated by ${algorithmName} tool. The result was computed from the following assets: `;

			const assetsDescriptions = Object.keys(selectedAssets).map(
				(key, index) =>
					` - Band ${index + 1}: [${selectedAssets[key].title}](${selectedAssets[key].href})`
			);
			description = `${description}<br>${assetsDescriptions.join('<br>')}`;
			feature.properties.description = description;

			feature.properties.links?.forEach((link) => {
				const newLink = new URL(link.href);
				if (newLink.searchParams.get('url')) {
					newLink.searchParams.set('url', vrtUrl);
					link.href = newLink.href;
				}
			});

			const assetTags = Object.keys(selectedAssets).map((name) => {
				return { key: 'asset', value: selectedAssets[name].href };
			});
			// set tags for default style creation
			feature.properties.tags = [
				{ key: 'type', value: 'azure' },
				...feature.properties.tags.filter((t) => ['provider', ALGORITHM_TAG_KEY].includes(t.key)),
				...assetTags,
				{
					key: ALGORITHM_TAG_KEY,
					value: selectedTool.algorithmId
				}
			];

			const rasterTile = new RasterTileData(feature);

			// set colormap name if it is available in algorithm metadata
			const colormap_name = selectedTool.algorithm.outputs.colormap_name ?? undefined;

			const data: LayerCreationInfo & { geohubLayer?: Layer } = await rasterTile.add(
				undefined,
				undefined,
				colormap_name,
				selectedTool.algorithmId
			);
			// revert tags to original
			feature.properties.tags = JSON.parse(JSON.stringify(dataset.properties.tags));
			feature.properties.tags = [
				...feature.properties.tags,
				...assetTags,
				{
					key: ALGORITHM_TAG_KEY,
					value: selectedTool.algorithmId
				}
			];

			// set unit if it is available in algorithm metadata
			if (selectedTool.algorithm.outputs.unit) {
				feature.properties.tags.push({
					key: 'unit',
					value: selectedTool.algorithm.outputs.unit
				});
			}

			data.geohubLayer = {
				id: data.layer.id,
				name: feature.properties.name,
				info: data.metadata,
				dataset: feature,
				colorMapName: data.colormap_name
			};

			dispatch('dataAdded', {
				layers: [data]
			});
		} catch (err) {
			console.error(err);
			errorMessage = err.message;
		} finally {
			isAdding = false;
		}
	};
</script>

{#if breadcrumbs && breadcrumbs.length > 0}
	<Breadcrumbs bind:pages={breadcrumbs} size="small" on:click={handleBreadcrumbClicked} />
{/if}

{#if dataset}
	{#each breadcrumbs as page, index}
		{@const isLastPage = index === breadcrumbs.length - 1}
		<div hidden={!isLastPage}>
			{#if page.type === 'index'}
				<RasterAlgorithmExplorer
					bind:feature={dataset}
					mode="select"
					toggleTool={false}
					on:selected={handleToolSelected}
				/>
			{:else if page.type === 'tool'}
				{#if selectedTool}
					<FieldControl title="Select input data" showHelpPopup={false}>
						<div slot="control">
							{#if selectedTool.algorithm.inputs.bands}
								{#each selectedTool.algorithm.inputs.bands as band, index}
									<div class="field">
										<!-- svelte-ignore a11y-label-has-associated-control -->
										<label class="label"
											>{band.title} ({band.required ? 'Required' : 'Optional'})</label
										>
										<div class="control">
											<StacCatalogDatePicker
												bind:collectionUrl
												bind:collection
												bind:selectedAsset={selectedAssets[index]}
												bind:selectedDate={selectedDates[index]}
												bind:algorithm={selectedTool.algorithm}
												bandIndex={index}
												on:assetChanged={(e) => {
													selectedAssets[index] = e.detail.asset;
													selectedAssets = { ...selectedAssets };
												}}
												on:dateChanged={(e) => {
													handleDateSelected(e.detail.date, index);
												}}
											/>
										</div>
										<p class="help is-success">{band.description}</p>
									</div>
								{/each}
							{:else}
								{#each listOfbands(selectedTool.algorithm.inputs.nbands) as bandNo}
									<div class="field">
										<!-- svelte-ignore a11y-label-has-associated-control -->
										<label class="label">Input Band {bandNo}</label>
										<div class="control">
											<StacCatalogDatePicker
												bind:collectionUrl
												bind:collection
												bind:selectedAsset={selectedAssets[bandNo]}
												bind:selectedDate={selectedDates[bandNo]}
												bind:algorithm={selectedTool.algorithm}
												bandIndex={bandNo - 1}
												on:assetChanged={(e) => {
													selectedAssets[index] = e.detail.asset;
													selectedAssets = { ...selectedAssets };
												}}
												on:dateChanged={(e) => {
													handleDateSelected(e.detail.date, bandNo);
												}}
											/>
										</div>
									</div>
								{/each}
							{/if}
						</div>
						<div slot="help">{selectedTool.algorithm.description}</div>
					</FieldControl>
				{/if}

				{#key selectedAssets}
					{#if Object.keys(selectedAssets).length > 0}
						{@const isDuplicated = isAssetDuplicated()}
						{@const isAllSelected =
							selectedTool.algorithm.inputs.nbands ===
								Object.keys(selectedAssets).filter((key) => selectedAssets[key] !== undefined)
									.length ||
							selectedTool.algorithm.inputs.bands?.length ===
								Object.keys(selectedAssets).filter((key) => selectedAssets[key] !== undefined)
									.length}

						{#if isDuplicated || errorMessage || !isAllSelected}
							<Notification type="danger" showCloseButton={false}>
								{#if isDuplicated}
									Same item was selected several times. Please assign different date and item each
									input band.
								{:else if !isAllSelected}
									Please select an asset item for each input band.
								{:else if errorMessage}
									The server returned an error ({errorMessage}). Please try again later.
								{/if}
							</Notification>
						{/if}

						<button
							class="button is-primary is-uppercase has-text-weight-bold mt-2 {isAdding
								? 'is-loading'
								: ''}"
							disabled={isDuplicated || !isAllSelected || isAdding}
							on:click={handleClickAdd}>Add to map</button
						>
					{/if}
				{/key}
			{/if}
		</div>
	{/each}
{/if}
