<script context="module" lang="ts">
	interface ToolBreadcrumb extends BreadcrumbPage {
		type: 'index' | 'tool';
	}
</script>

<script lang="ts">
	import RasterAlgorithmExplorer, {
		ALGORITHM_TAG_KEY
	} from '$components/maplibre/raster/RasterAlgorithmExplorer.svelte';
	import { RasterTileData } from '$lib/RasterTileData';
	import { generateHashKey } from '$lib/helper';
	import type {
		DatasetFeature,
		Layer,
		LayerCreationInfo,
		RasterAlgorithm,
		StacAsset,
		StacCollection,
		Tag
	} from '$lib/types';
	import {
		Breadcrumbs,
		FieldControl,
		Notification,
		type BreadcrumbPage
	} from '@undp-data/svelte-undp-components';
	import { createEventDispatcher } from 'svelte';
	import StacCatalogDatePicker from './StacCatalogDatePicker.svelte';

	const dispatch = createEventDispatcher();

	export let collectionUrl: string;
	export let collection: StacCollection;
	export let dataset: DatasetFeature = undefined;

	let selectedTool: { algorithmId: string; algorithm: RasterAlgorithm };

	let selectedAssets: { [key: number]: StacAsset } = {};

	let breadcrumbs: ToolBreadcrumb[] = [
		{
			title: 'Tool Menu',
			type: 'index'
		}
	];

	const handleToolSelected = (e) => {
		const tag: Tag = e.detail.tag;
		const algorithm: RasterAlgorithm = e.detail.algorithm;
		selectedTool = {
			algorithmId: tag.value,
			algorithm
		};
		selectedAssets = {};
		breadcrumbs = [
			...breadcrumbs,
			{
				title: algorithm.title ?? selectedTool.algorithmId,
				type: 'tool'
			}
		];
	};

	const handleBreadcrumbClicked = (e) => {
		const page: ToolBreadcrumb = e.detail;
		if (breadcrumbs?.length > 0) {
			const pageIndex = breadcrumbs.findIndex((p) => p.title === page.title);
			breadcrumbs = [...breadcrumbs.slice(0, pageIndex + 1)];
		}
	};

	const listOfbands = (nbands: number) => {
		const list = [];
		for (let i = 1; i <= nbands; i++) {
			list.push(i);
		}
		return list;
	};

	const isAssetDuplicated = () => {
		const assetCount: { [key: string]: number } = {};
		Object.keys(selectedAssets).forEach((key) => {
			const value = selectedAssets[key];
			if (!value) return;
			if (!assetCount[value.href]) {
				assetCount[value.href] = 0;
			}
			assetCount[value.href] += 1;
		});
		return Object.keys(assetCount).filter((key) => assetCount[key] > 1).length > 0;
	};

	const handleClickAdd = async () => {
		const urls = Object.keys(selectedAssets).map(
			(key) => `url=${encodeURIComponent(selectedAssets[key].href)}`
		);
		let vrtUrl = dataset.properties.links.find((l) => l.rel === 'vrt')?.href;
		if (!vrtUrl) return;
		vrtUrl = `${vrtUrl}?${urls.join('&')}`;

		const algorithmName = selectedTool.algorithm.title ?? selectedTool.algorithmId;

		const feature: DatasetFeature = JSON.parse(JSON.stringify(dataset));
		feature.properties.url = vrtUrl;
		feature.properties.id = generateHashKey(vrtUrl);
		feature.properties.name = `${feature.properties.name} (${algorithmName})`;
		feature.properties.description = `${feature.properties.description}<br>The result was generated by ${algorithmName} tool`;

		feature.properties.links?.forEach((link) => {
			link.href = link.href
				.replace('{url}', encodeURIComponent(vrtUrl))
				.replace('{algorithm}', selectedTool.algorithmId);
		});
		const stacType = feature.properties.tags.find((t) => t.key === 'stacType');
		stacType.value = 'cog';

		const assetTags = Object.keys(selectedAssets).map((name) => {
			return { key: 'asset', value: selectedAssets[name].href };
		});
		feature.properties.tags = [
			...feature.properties.tags,
			...assetTags,
			{
				key: ALGORITHM_TAG_KEY,
				value: selectedTool.algorithmId
			}
		];

		const rasterTile = new RasterTileData(feature);
		const metadata = await rasterTile.getMetadata(selectedTool.algorithmId);
		metadata.active_band_no = Object.keys(metadata.stats)[0];

		const data: LayerCreationInfo & { geohubLayer?: Layer } = await rasterTile.add();

		// const data: LayerCreationInfo & { geohubLayer?: Layer } = layerData;

		feature.properties.tags = [
			{ key: 'type', value: 'azure' },
			...feature.properties.tags.filter((t) =>
				['stac', 'collection', 'provider', 'asset', ALGORITHM_TAG_KEY].includes(t.key)
			)
		];

		data.geohubLayer = {
			id: data.layer.id,
			name: feature.properties.name,
			info: data.metadata,
			dataset: feature,
			colorMapName: data.colormap_name
		};
		console.log(data);
		dispatch('dataAdded', {
			layers: [data]
		});
	};
</script>

{#if breadcrumbs && breadcrumbs.length > 0}
	<Breadcrumbs bind:pages={breadcrumbs} size="small" on:click={handleBreadcrumbClicked} />
{/if}

{#if dataset}
	{#each breadcrumbs as page, index}
		{@const isLastPage = index === breadcrumbs.length - 1}
		<div hidden={!isLastPage}>
			{#if page.type === 'index'}
				<RasterAlgorithmExplorer
					bind:feature={dataset}
					mode="select"
					toggleTool={false}
					on:selected={handleToolSelected}
				/>
			{:else if page.type === 'tool'}
				{#if selectedTool}
					<FieldControl title="Select input data" showHelpPopup={false}>
						<div slot="control">
							{#if selectedTool.algorithm.inputs.bands}
								{#each selectedTool.algorithm.inputs.bands as band, index}
									<div class="field">
										<!-- svelte-ignore a11y-label-has-associated-control -->
										<label class="label"
											>{band.title} ({band.required ? 'Required' : 'Optional'})</label
										>
										<div class="control">
											<StacCatalogDatePicker
												bind:collectionUrl
												bind:collection
												bind:selectedAsset={selectedAssets[index]}
											/>
										</div>
										<p class="help is-success">{band.description}</p>
									</div>
								{/each}
							{:else}
								{#each listOfbands(selectedTool.algorithm.inputs.nbands) as bandNo}
									<div class="field">
										<!-- svelte-ignore a11y-label-has-associated-control -->
										<label class="label">Input Band {bandNo}</label>
										<div class="control">
											<StacCatalogDatePicker
												bind:collectionUrl
												bind:collection
												bind:selectedAsset={selectedAssets[bandNo]}
											/>
										</div>
									</div>
								{/each}
							{/if}
						</div>
						<div slot="help">{selectedTool.algorithm.description}</div>
					</FieldControl>
				{/if}

				{#key selectedAssets}
					{#if Object.keys(selectedAssets).length > 0}
						{@const isDuplicated = isAssetDuplicated()}
						{@const isAllSelected =
							selectedTool.algorithm.inputs.nbands === Object.keys(selectedAssets).length ||
							selectedTool.algorithm.inputs.bands?.length === Object.keys(selectedAssets).length}

						{#if isDuplicated}
							<Notification type="danger" showCloseButton={false}>
								Same item was selected several times. Please assign different date and item each
								input band.
							</Notification>
						{/if}

						<button
							class="button is-primary is-uppercase has-text-weight-bold"
							disabled={isDuplicated || !isAllSelected}
							on:click={handleClickAdd}>Add to map</button
						>
					{/if}
				{/key}
			{/if}
		</div>
	{/each}
{/if}
