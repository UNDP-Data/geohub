<script lang="ts">
	import { ALGORITHM_TAG_KEY } from '$components/maplibre/raster/RasterAlgorithmExplorer.svelte';
	import { RasterTileData } from '$lib/RasterTileData';
	import { generateHashKey } from '$lib/helper';
	import type {
		DatasetFeature,
		Layer,
		LayerCreationInfo,
		RasterAlgorithm,
		StacAsset,
		StacCollection
	} from '$lib/types';
	import { FieldControl, Notification } from '@undp-data/svelte-undp-components';
	import { createEventDispatcher } from 'svelte';
	import StacCatalogDatePicker from './StacCatalogDatePicker.svelte';

	const dispatch = createEventDispatcher();

	export let collectionUrl: string;
	export let collection: StacCollection;
	export let dataset: DatasetFeature = undefined;
	export let selectedTool: { algorithmId: string; algorithm: RasterAlgorithm };

	let isAdding = false;
	let errorMessage = '';

	let selectedAssets: { [key: number]: StacAsset } = {};

	let selectedDates: { [key: number]: Date } = {};

	const handleDateSelected = (date: Date, index: number) => {
		const isFirstBand =
			Object.keys(selectedAssets)
				.map((k) => k.toString())
				.findIndex((k) => k === index.toString()) === 0;
		if (!isFirstBand) return;
		// if first band date is changed, update other later bands
		Object.keys(selectedAssets)
			.filter((k) => k !== index.toString())
			.forEach((k) => {
				selectedAssets[k] = undefined;
				selectedDates[k] = new Date(date);
			});
	};

	const listOfbands = (nbands: number) => {
		const list = [];
		for (let i = 1; i <= nbands; i++) {
			list.push(i);
		}
		return list;
	};

	const isAssetDuplicated = () => {
		const assetCount: { [key: string]: number } = {};
		Object.keys(selectedAssets).forEach((key) => {
			const value = selectedAssets[key];
			if (!value) return;
			if (!assetCount[value.href]) {
				assetCount[value.href] = 0;
			}
			assetCount[value.href] += 1;
		});
		return Object.keys(assetCount).filter((key) => assetCount[key] > 1).length > 0;
	};

	const handleClickAdd = async () => {
		try {
			isAdding = true;
			errorMessage = '';

			const urls = Object.keys(selectedAssets).map(
				(key) => `url=${encodeURIComponent(selectedAssets[key].href)}`
			);
			console.log(dataset);
			let vrtUrl = dataset.properties.links.find((l) => l.rel === 'vrt')?.href;
			if (!vrtUrl) return;
			vrtUrl = `${vrtUrl.indexOf('localhost') === -1 ? vrtUrl : '/vrt'}?${urls.join('&')}`;
			const algorithmName = selectedTool.algorithm.title ?? selectedTool.algorithmId;

			let feature: DatasetFeature = JSON.parse(JSON.stringify(dataset));
			feature.properties.url = vrtUrl;
			feature.properties.id = generateHashKey(vrtUrl);
			feature.properties.name = `${feature.properties.name} (${algorithmName})`;
			let description = `${feature.properties.description}<br>The result was generated by ${algorithmName} tool. The result was computed from the following assets: `;

			const assetsDescriptions = Object.keys(selectedAssets).map(
				(key, index) =>
					` - Band ${index + 1}: [${selectedAssets[key].title}](${selectedAssets[key].href})`
			);
			description = `${description}<br>${assetsDescriptions.join('<br>')}`;
			feature.properties.description = description;

			feature.properties.links?.forEach((link) => {
				const newLink = new URL(link.href);
				if (newLink.searchParams.get('url')) {
					newLink.searchParams.set('url', vrtUrl);
					link.href = newLink.href;
				}
			});
			console.log(feature);
			const assetTags = Object.keys(selectedAssets).map((name) => {
				return { key: 'asset', value: selectedAssets[name].href };
			});
			// set tags for default style creation
			feature.properties.tags = [
				{ key: 'type', value: 'azure' },
				...feature.properties.tags.filter((t) => ['provider', ALGORITHM_TAG_KEY].includes(t.key)),
				...assetTags,
				{
					key: ALGORITHM_TAG_KEY,
					value: selectedTool.algorithmId
				}
			];

			const rasterTile = new RasterTileData(feature);

			// set colormap name if it is available in algorithm metadata
			const colormap_name = selectedTool.algorithm.outputs.colormap_name ?? undefined;

			const data: LayerCreationInfo & { geohubLayer?: Layer } = await rasterTile.add(
				undefined,
				undefined,
				colormap_name,
				selectedTool.algorithmId
			);
			// revert tags to original
			feature.properties.tags = JSON.parse(JSON.stringify(dataset.properties.tags));
			feature.properties.tags = [
				...feature.properties.tags,
				...assetTags,
				{
					key: ALGORITHM_TAG_KEY,
					value: selectedTool.algorithmId
				}
			];

			// set unit if it is available in algorithm metadata
			if (selectedTool.algorithm.outputs.unit) {
				feature.properties.tags.push({
					key: 'unit',
					value: selectedTool.algorithm.outputs.unit
				});
			}

			data.geohubLayer = {
				id: data.layer.id,
				name: feature.properties.name,
				info: data.metadata,
				dataset: feature,
				colorMapName: data.colormap_name
			};

			dispatch('dataAdded', {
				layers: [data]
			});
		} catch (err) {
			console.error(err);
			errorMessage = err.message;
		} finally {
			isAdding = false;
		}
	};
</script>

{#if dataset}
	{#if selectedTool}
		<FieldControl title="Select input data" showHelpPopup={false}>
			<div slot="control">
				{#if selectedTool.algorithm.inputs.bands}
					{#each selectedTool.algorithm.inputs.bands as band, index}
						<div class="field">
							<!-- svelte-ignore a11y-label-has-associated-control -->
							<label class="label">{band.title} ({band.required ? 'Required' : 'Optional'})</label>
							<div class="control">
								<StacCatalogDatePicker
									bind:collectionUrl
									bind:collection
									bind:selectedAsset={selectedAssets[index]}
									bind:selectedDate={selectedDates[index]}
									bind:algorithm={selectedTool.algorithm}
									bandIndex={index}
									on:assetChanged={(e) => {
										selectedAssets[index] = e.detail.asset;
										selectedAssets = { ...selectedAssets };
									}}
									on:dateChanged={(e) => {
										handleDateSelected(e.detail.date, index);
									}}
								/>
							</div>
							<p class="help is-success">{band.description}</p>
						</div>
					{/each}
				{:else}
					{#each listOfbands(selectedTool.algorithm.inputs.nbands) as bandNo}
						<div class="field">
							<!-- svelte-ignore a11y-label-has-associated-control -->
							<label class="label">Input Band {bandNo}</label>
							<div class="control">
								<StacCatalogDatePicker
									bind:collectionUrl
									bind:collection
									bind:selectedAsset={selectedAssets[bandNo]}
									bind:selectedDate={selectedDates[bandNo]}
									bind:algorithm={selectedTool.algorithm}
									bandIndex={bandNo - 1}
									on:assetChanged={(e) => {
										selectedAssets[bandNo] = e.detail.asset;
										selectedAssets = { ...selectedAssets };
									}}
									on:dateChanged={(e) => {
										handleDateSelected(e.detail.date, bandNo);
									}}
								/>
							</div>
						</div>
					{/each}
				{/if}
			</div>
			<div slot="help">{selectedTool.algorithm.description}</div>
		</FieldControl>
	{/if}

	{#key selectedAssets}
		{#if Object.keys(selectedAssets).length > 0}
			{@const isDuplicated = isAssetDuplicated()}
			{@const isAllSelected =
				selectedTool.algorithm.inputs.nbands ===
					Object.keys(selectedAssets).filter((key) => selectedAssets[key] !== undefined).length ||
				selectedTool.algorithm.inputs.bands?.length ===
					Object.keys(selectedAssets).filter((key) => selectedAssets[key] !== undefined).length}

			{#if isDuplicated || errorMessage || !isAllSelected}
				<Notification type="danger" showCloseButton={false}>
					{#if isDuplicated}
						Same item was selected several times. Please assign different date and item each input
						band.
					{:else if !isAllSelected}
						Please select an asset item for each input band.
					{:else if errorMessage}
						The server returned an error ({errorMessage}). Please try again later.
					{/if}
				</Notification>
			{/if}

			<button
				class="button is-primary is-uppercase has-text-weight-bold mt-2 {isAdding
					? 'is-loading'
					: ''}"
				disabled={isDuplicated || !isAllSelected || isAdding}
				on:click={handleClickAdd}>Add to map</button
			>
		{/if}
	{/key}
{/if}
