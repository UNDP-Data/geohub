<script lang="ts">
	import { ALGORITHM_TAG_KEY } from '$components/pages/map/data/RasterAlgorithmExplorer.svelte';
	import { RasterTileData } from '$lib/RasterTileData';
	import { generateHashKey } from '$lib/helper';
	import type {
		DatasetFeature,
		Layer,
		LayerCreationInfo,
		StacAsset,
		StacCollection,
		StacDataLayer
	} from '$lib/types';
	import {
		FieldControl,
		Notification,
		type RasterAlgorithm
	} from '@undp-data/svelte-undp-components';
	import StacCatalogDatePicker from './StacCatalogDatePicker.svelte';

	interface Props {
		collectionUrl: string;
		collection: StacCollection;
		dataset?: DatasetFeature;
		selectedTool: { algorithmId: string; algorithm: RasterAlgorithm };
		onDataAdded?: (layers: StacDataLayer[]) => void;
	}

	let {
		collectionUrl = $bindable(),
		collection = $bindable(),
		dataset = $bindable(),
		selectedTool = $bindable(),
		onDataAdded = () => {}
	}: Props = $props();

	let isAdding = $state(false);
	let errorMessage = $state('');

	let selectedAssets: { [key: number]: StacAsset } = $state({});

	let selectedDates: { [key: number]: Date } = $state({});

	const handleDateSelected = (date: Date, index: number) => {
		const isFirstBand =
			Object.keys(selectedAssets)
				.map((k) => k.toString())
				.findIndex((k) => k === index.toString()) === 0;
		if (!isFirstBand) return;
		// if first band date is changed, update other later bands
		Object.keys(selectedAssets)
			.filter((k) => k !== index.toString())
			.forEach((k) => {
				selectedAssets[k] = undefined;
				selectedDates[k] = new Date(date);
			});
	};

	const listOfbands = (nbands: number) => {
		const list = [];
		for (let i = 1; i <= nbands; i++) {
			list.push(i);
		}
		return list;
	};

	const isAssetDuplicated = () => {
		const assetCount: { [key: string]: number } = {};
		Object.keys(selectedAssets).forEach((key) => {
			const value = selectedAssets[key];
			if (!value) return;
			if (!assetCount[value.href]) {
				assetCount[value.href] = 0;
			}
			assetCount[value.href] += 1;
		});
		return Object.keys(assetCount).filter((key) => assetCount[key] > 1).length > 0;
	};

	const handleClickAdd = async () => {
		try {
			isAdding = true;
			errorMessage = '';

			const urls = Object.keys(selectedAssets).map(
				(key) => `url=${encodeURIComponent(selectedAssets[key].href)}`
			);
			let vrtUrl = dataset.properties.links.find((l) => l.rel === 'vrt')?.href;
			if (!vrtUrl) return;
			vrtUrl = `${vrtUrl.indexOf('localhost') === -1 ? vrtUrl : '/vrt'}?${urls.join('&')}`;
			const algorithmName = selectedTool.algorithm.title ?? selectedTool.algorithmId;

			let feature: DatasetFeature = JSON.parse(JSON.stringify(dataset));
			feature.properties.url = vrtUrl;
			feature.properties.id = generateHashKey(vrtUrl);
			feature.properties.name = `${feature.properties.name} (${algorithmName})`;
			let description = `${feature.properties.description}<br>The result was generated by ${algorithmName} tool. The result was computed from the following assets: `;

			const assetsDescriptions = Object.keys(selectedAssets).map(
				(key, index) =>
					` - Band ${index + 1}: [${selectedAssets[key].title}](${selectedAssets[key].href})`
			);
			description = `${description}<br>${assetsDescriptions.join('<br>')}`;
			feature.properties.description = description;

			feature.properties.links?.forEach((link) => {
				const newLink = new URL(link.href);
				if (newLink.searchParams.get('url')) {
					newLink.searchParams.set('url', vrtUrl);
					link.href = newLink.href;
				}
			});

			const assetTags = Object.keys(selectedAssets).map((name) => {
				return { key: 'asset', value: selectedAssets[name].href };
			});
			// set tags for default style creation
			feature.properties.tags = [
				{ key: 'type', value: 'azure' },
				...feature.properties.tags.filter((t) => ['provider', ALGORITHM_TAG_KEY].includes(t.key)),
				...assetTags,
				{
					key: ALGORITHM_TAG_KEY,
					value: selectedTool.algorithmId
				}
			];

			const rasterTile = new RasterTileData(feature);

			// set colormap name if it is available in algorithm metadata
			const colormap_name = selectedTool.algorithm.outputs.colormap_name ?? undefined;

			const data: LayerCreationInfo & { geohubLayer?: Layer } = await rasterTile.add(
				undefined,
				undefined,
				colormap_name,
				selectedTool.algorithmId
			);
			// revert tags to original
			feature.properties.tags = JSON.parse(JSON.stringify(dataset.properties.tags));
			feature.properties.tags = [
				...feature.properties.tags,
				...assetTags,
				{
					key: ALGORITHM_TAG_KEY,
					value: selectedTool.algorithmId
				}
			];

			// set unit if it is available in algorithm metadata
			if (selectedTool.algorithm.outputs.unit) {
				feature.properties.tags.push({
					key: 'unit',
					value: selectedTool.algorithm.outputs.unit
				});
			}

			data.geohubLayer = {
				id: data.layer.id,
				name: feature.properties.name,
				info: data.metadata,
				dataset: feature,
				colorMapName: data.colormap_name
			};
			if (onDataAdded) onDataAdded([data]);
		} catch (err) {
			console.error(err);
			errorMessage = err.message;
		} finally {
			isAdding = false;
		}
	};
</script>

{#if dataset}
	{#if selectedTool}
		<FieldControl title="Select input data" showHelpPopup={false}>
			{#snippet control()}
				<div>
					{#if selectedTool.algorithm.inputs.bands}
						{@const bands = selectedTool.algorithm.inputs.bands}
						{#each bands as band, index (bands.indexOf(band))}
							<div class="field">
								<!-- svelte-ignore a11y_label_has_associated_control -->
								<label class="label">{band.title} ({band.required ? 'Required' : 'Optional'})</label
								>
								<div class="control">
									<StacCatalogDatePicker
										bind:collectionUrl
										bind:collection
										bind:selectedAsset={selectedAssets[index]}
										bind:selectedDate={selectedDates[index]}
										bind:algorithm={selectedTool.algorithm}
										bandIndex={index}
										onAssetChanged={(asset: StacAsset) => {
											selectedAssets[index] = asset;
											selectedAssets = { ...selectedAssets };
										}}
										onDateChanged={(date: Date) => {
											handleDateSelected(date, index);
										}}
									/>
								</div>
								<p class="help is-success">{band.description}</p>
							</div>
						{/each}
					{:else}
						{#each listOfbands(selectedTool.algorithm.inputs.nbands) as bandNo (bandNo)}
							<div class="field">
								<!-- svelte-ignore a11y_label_has_associated_control -->
								<label class="label">Input Band {bandNo}</label>
								<div class="control">
									<StacCatalogDatePicker
										bind:collectionUrl
										bind:collection
										bind:selectedAsset={selectedAssets[bandNo]}
										bind:selectedDate={selectedDates[bandNo]}
										bind:algorithm={selectedTool.algorithm}
										bandIndex={bandNo - 1}
										onAssetChanged={(asset: StacAsset) => {
											selectedAssets[bandNo] = asset;
											selectedAssets = { ...selectedAssets };
										}}
										onDateChanged={(date: Date) => {
											handleDateSelected(date, bandNo);
										}}
									/>
								</div>
							</div>
						{/each}
					{/if}
				</div>
			{/snippet}
			{#snippet help()}
				<div>{selectedTool.algorithm.description}</div>
			{/snippet}
		</FieldControl>
	{/if}

	{#key selectedAssets}
		{#if Object.keys(selectedAssets).length > 0}
			{@const isDuplicated = isAssetDuplicated()}
			{@const isAllSelected =
				selectedTool.algorithm.inputs.nbands ===
					Object.keys(selectedAssets).filter((key) => selectedAssets[key] !== undefined).length ||
				selectedTool.algorithm.inputs.bands?.length ===
					Object.keys(selectedAssets).filter((key) => selectedAssets[key] !== undefined).length}

			{#if isDuplicated || errorMessage || !isAllSelected}
				<Notification type="danger" showCloseButton={false}>
					{#if isDuplicated}
						Same item was selected several times. Please assign different date and item each input
						band.
					{:else if !isAllSelected}
						Please select an asset item for each input band.
					{:else if errorMessage}
						The server returned an error ({errorMessage}). Please try again later.
					{/if}
				</Notification>
			{/if}

			<button
				class="button is-primary is-uppercase has-text-weight-bold mt-2 {isAdding
					? 'is-loading'
					: ''}"
				disabled={isDuplicated || !isAllSelected || isAdding}
				onclick={handleClickAdd}>Add to map</button
			>
		{/if}
	{/key}
{/if}
