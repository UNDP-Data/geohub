<script lang="ts">
	import ColorPicker from '$components/util/ColorPicker.svelte';
	import { handleEnterKey, initTippy } from '$lib/helper';
	import type { ColorMapRow } from '$lib/types';
	import chroma from 'chroma-js';
	import { createEventDispatcher } from 'svelte';
	import type { RgbaColor } from 'svelte-awesome-color-picker';

	const tippy = initTippy();
	let tooltipContent: HTMLElement;

	export let colorMapRow: ColorMapRow;
	export let colorMapName: string;
	export let rowWidth: number;
	export let hasUniqueValues: boolean;
	let signal;
	const dispatch = createEventDispatcher();

	let color: RgbaColor;
	let colorPickerStyle: string;

	$: colorMapRow.color, getColorPickerStyle();

	// load color map upon change of layer color map name
	$: colorMapName, setColorFromProp();

	$: isVisible = color.a !== 0;

	// set color based on default value
	const setColorFromProp = () => {
		const rowColor: number[] = colorMapRow.color;
		const r = rowColor[0];
		const g = rowColor[1];
		const b = rowColor[2];
		const a = rowColor[3];

		color = {
			r,
			g,
			b,
			a
		};
	};

	const getColorPickerStyle = () => {
		if (!color) return;
		let rgba = chroma(color.r, color.g, color.b, color.a).css();
		const rgba2 = chroma(colorMapRow.color).css();
		if (rgba !== rgba2) {
			rgba = rgba2;
			setColorFromProp();
		}
		colorPickerStyle = `caret-color:${rgba}; background-color: ${rgba}`;
		return colorPickerStyle;
	};

	$: isVisible, handleVisibilityChanged();
	const handleVisibilityChanged = () => {
		if (isVisible) {
			color.a = 1;
		} else {
			[(color.a = 0)];
		}
		updateColorMap(color);
	};

	// set color of display and dispatch to update map
	const updateColorMap = (colorSelected: RgbaColor) => {
		if (colorSelected) {
			try {
				const { r, g, b, a } = colorSelected;
				let rgba: number[] = [r, g, b, a];

				/*the fix below is necessary becuse the Color picker has some rounding errors generated by
          computing the position of the color selector in percentages and emits an incredible number of events
          which make the color returned change slightly on multiple consecutive invocations without touching the selector
          for example and this triggers map rerendering in vain
          The solutin is to detect changes for every dimension of the color, sum the differences and only
          update the map on a consistent color change (larger delta)
        */
				colorMapRow.color = rgba;
				colorPickerStyle = getColorPickerStyle();
				dispatch('changeColorMap');
			} catch (e) {
				console.log(e);
			}
		}
	};

	const handleColorChanged = () => {
		updateColorMap(color);
	};

	const handleInput = (e) => {
		const id = e.target.id;
		const value = (e.target as HTMLInputElement).value;
		signal = value;
		dispatch('changeIntervalValues', {
			index: colorMapRow.index,
			id,
			value: parseFloat(value)
		});
	};
</script>

<!--
the key statement is necessary as it forces to rerender the legend item in case an invalid valus is provided
-->
{#key signal}
	<div class="columns is-mobile p-0 m-0 py-1">
		<div class="column is-1 p-0 m-0">
			<div
				role="button"
				tabindex="0"
				class="visible-button icon"
				on:click={() => (isVisible = !isVisible)}
				on:keydown={handleEnterKey}
			>
				{#if isVisible}
					<i class="fa-solid fa-eye" />
				{:else}
					<i class="fa-solid fa-eye-slash" />
				{/if}
			</div>
		</div>
		<div class="column is-2 p-0 m-0">
			<div
				title="Color Map Control"
				use:tippy={{ content: tooltipContent }}
				class="discrete"
				style="{colorPickerStyle}; width:20px; height:20px"
			/>
			<div class="tooltip" data-testid="tooltip" bind:this={tooltipContent}>
				<ColorPicker bind:color on:changeColor={handleColorChanged} />
			</div>
		</div>
		{#if !hasUniqueValues}
			<div class="column p-0 m-0">
				<input
					style="width:{rowWidth * 8}px; max-width:100px"
					class="number-input"
					id="start"
					type="number"
					value={colorMapRow.start}
					on:change={handleInput}
					required
				/>
			</div>
		{/if}
		<div class="is-3 column p-0 m-0">
			<p style={hasUniqueValues ? 'margin-left: 20%' : `margin-left: ${rowWidth + 5}px`}>â€”</p>
		</div>
		<div class="column p-0 m-0">
			{#if hasUniqueValues}
				<span>
					{isNaN(parseFloat(`${colorMapRow.end}`)) ? colorMapRow.end : colorMapRow.start}
				</span>
			{:else}
				<input
					style={`width:${rowWidth * 8}px; max-width:100px`}
					class="number-input"
					type="number"
					id="end"
					value={colorMapRow.end}
					on:change={handleInput}
					required
				/>
			{/if}
		</div>
	</div>
{/key}

<style lang="scss">
	@import 'tippy.js/dist/tippy.css';
	@import 'tippy.js/themes/light.css';

	$input-margin: 5px !important;

	.tooltip {
		z-index: 10;
		padding: 0;
		height: 255px;
		width: 260px;
	}

	.visible-button {
		cursor: pointer;
	}

	.number-input {
		width: 100%;
		text-align: left;
		border: none;
		background-color: transparent;
	}

	.discrete {
		cursor: pointer !important;
		height: 20px;
		width: 20px;
		border: 1px solid gray;
	}

	:global(.discrete):hover {
		padding: 0;
		border: 2px solid rgb(0, 0, 0);
	}

	input:focus {
		outline: none;
		background: rgb(220, 220, 220, 0.3);
	}

	input::-webkit-outer-spin-button,
	input::-webkit-inner-spin-button {
		-webkit-appearance: none;
		margin: 0;
	}

	input[type='number'] {
		-moz-appearance: textfield;
	}

	// #tooltip {
	//   height: 280px;
	//   padding: 0;
	//   width: 290px;
	//   max-width: 290px;
	// }
</style>
