<script lang="ts">
  import { createEventDispatcher } from 'svelte'
  import chroma from 'chroma-js'
  import ColorPicker from '$components/controls/ColorPicker.svelte'
  import type { ColorMapRow } from '$lib/types'
  import type { RgbaColor } from 'svelte-awesome-color-picker'
  import { initTippy } from '$lib/helper'

  const tippy = initTippy()
  let tooltipContent: HTMLElement

  export let colorMapRow: ColorMapRow
  export let colorMapName: string
  export let rowWidth
  export let hasUniqueValues: boolean
  let signal
  const dispatch = createEventDispatcher()

  let color: RgbaColor
  let colorPickerStyle: string

  $: colorMapRow.color, getColorPickerStyle()

  // load color map upon change of layer color map name
  $: colorMapName, setColorFromProp()

  $: isVisible = color.a !== 0

  // set color based on default value
  const setColorFromProp = () => {
    const rowColor: number[] = colorMapRow.color
    const r = rowColor[0]
    const g = rowColor[1]
    const b = rowColor[2]
    const a = rowColor[3]

    color = {
      r,
      g,
      b,
      a,
    }
  }

  const getColorPickerStyle = () => {
    if (!color) return
    let rgba = chroma(color.r, color.g, color.b, color.a).css()
    const rgba2 = chroma(colorMapRow.color).css()
    if (rgba !== rgba2) {
      rgba = rgba2
      setColorFromProp()
    }
    colorPickerStyle = `caret-color:${rgba}; background-color: ${rgba}`
    return colorPickerStyle
  }

  $: isVisible, handleVisibilityChanged()
  const handleVisibilityChanged = () => {
    if (isVisible) {
      color.a = 1
    } else {
      ;[(color.a = 0)]
    }
    updateColorMap(color)
  }

  // set color of display and dispatch to update map
  const updateColorMap = (colorSelected: RgbaColor) => {
    if (colorSelected) {
      try {
        const { r, g, b, a } = colorSelected
        let rgba: number[] = [r, g, b, a]

        /*the fix below is necessary becuse the Color picker has some rounding errors generated by
          computing the position of the color selector in percentages and emits an incredible number of events
          which make the color returned change slightly on multiple consecutive invocations without touching the selector
          for example and this triggers map rerendering in vain
          The solutin is to detect changes for every dimension of the color, sum the differences and only
          update the map on a consistent color change (larger delta)
        */
        colorMapRow.color = rgba
        colorPickerStyle = getColorPickerStyle()
        dispatch('changeColorMap')
      } catch (e) {
        console.log(e)
      }
    }
  }

  const handleColorChanged = () => {
    updateColorMap(color)
  }

  const handleInput = (e) => {
    const id = e.target.id
    const value = (e.target as HTMLInputElement).value
    signal = value
    dispatch('changeIntervalValues', {
      index: colorMapRow.index,
      id,
      value: parseFloat(value),
    })
  }

  const handleEnterKey = (e: KeyboardEvent) => {
    if (e.key === 'Enter') {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.target.click()
    }
  }
</script>

<!--
the key statement is necessary as it forces to rerender the legend item in case an invalid valus is provided
-->
{#key signal}
  <div class="columns is-mobile p-0 m-0 py-1">
    <div class="column is-1 p-0 m-0">
      <div
        role="button"
        class="visible-button icon"
        on:click={() => (isVisible = !isVisible)}
        on:keydown={handleEnterKey}>
        {#if isVisible}
          <i class="fa-solid fa-eye" />
        {:else}
          <i class="fa-solid fa-eye-slash" />
        {/if}
      </div>
    </div>
    <div class="column is-2 p-0 m-0">
      <!-- svelte-ignore a11y-click-events-have-key-events -->
      <div
        title="Color Map Control"
        use:tippy={{ content: tooltipContent }}
        class="discrete"
        style="{colorPickerStyle}; width:20px; height:20px" />
      <div
        class="tooltip"
        data-testid="tooltip"
        bind:this={tooltipContent}>
        <ColorPicker
          bind:color
          on:changeColor={handleColorChanged} />
      </div>
    </div>
    {#if !hasUniqueValues}
      <div class="column p-0 m-0">
        <input
          style="width:{rowWidth * 8}px; max-width:100px"
          class="number-input"
          id="start"
          type="number"
          value={colorMapRow.start}
          on:change={handleInput}
          required />
      </div>
    {/if}
    <div class="is-3 column p-0 m-0">
      <p style={hasUniqueValues ? 'margin-left: 20%' : `margin-left: ${rowWidth + 5}px`}>â€”</p>
    </div>
    <div class="column p-0 m-0">
      {#if hasUniqueValues}
        <span>
          {isNaN(parseFloat(colorMapRow.end)) ? colorMapRow.end : colorMapRow.start}
        </span>
      {:else}
        <input
          style={`width:${rowWidth * 8}px; max-width:100px`}
          class="number-input"
          type="number"
          id="end"
          value={colorMapRow.end}
          on:change={handleInput}
          required />
      {/if}
    </div>
  </div>
{/key}

<style lang="scss">
  @import 'tippy.js/dist/tippy.css';
  @import 'tippy.js/themes/light.css';

  $input-margin: 5px !important;

  .tooltip {
    z-index: 10;
    padding: 0;
    height: 255px;
    width: 260px;
  }

  .visible-button {
    cursor: pointer;
  }

  .number-input {
    width: 100%;
    text-align: left;
    border: none;
    background-color: transparent;
  }

  .discrete {
    cursor: pointer !important;
    height: 20px;
    width: 20px;
    border: 1px solid gray;
  }

  :global(.discrete):hover {
    padding: 0;
    border: 2px solid rgb(0, 0, 0);
  }

  input:focus {
    outline: none;
    background: rgb(220, 220, 220, 0.3);
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input[type='number'] {
    -moz-appearance: textfield;
  }

  // #tooltip {
  //   height: 280px;
  //   padding: 0;
  //   width: 290px;
  //   max-width: 290px;
  // }
</style>
