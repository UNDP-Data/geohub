<script lang="ts">
  import { createEventDispatcher } from 'svelte'
  import { fade } from 'svelte/transition'
  import chroma from 'chroma-js'
  import { abs } from 'mathjs'
  import { clickOutside } from 'svelte-use-click-outside'
  import ColorPicker from '$components/controls/ColorPicker.svelte'
  import Popper from '$lib/popper'
  import type { Color, IntervalLegendColorMapRow } from '$lib/types'

  export let colorMapRow: IntervalLegendColorMapRow
  export let colorMapName: string
  export let rowWidth

  let signal
  const dispatch = createEventDispatcher()
  const {
    ref: popperRef,
    options: popperOptions,
    content: popperContent,
  } = new Popper(
    {
      placement: 'right-start',
      strategy: 'fixed',
    },
    [10, 15],
  ).init()

  let color: Color
  let colorPickerStyle: string
  let showToolTip = false
  // $: colorPickerStyle = getColorPickerStyle()

  $: colorMapRow.color, getColorPickerStyle()
  $: color, updateColorMap(color)

  // load color map upon change of layer color map name
  $: colorMapName, setColorFromProp()

  $: isVisible = color.a === 0 ? false : true

  // set color based on default value
  const setColorFromProp = () => {
    const rowColor: number[] = colorMapRow.color
    const r = rowColor[0]
    const g = rowColor[1]
    const b = rowColor[2]
    const a = rowColor[3]

    // sometimes h is NaN, causing the colorpicker to break
    // To curb this, force it to zero
    color = {
      r,
      g,
      b,
      a,
      hex: chroma([r, g, b]).hex('rgba'),
      h: isNaN(chroma([r, g, b]).hsv()[0]) ? 0 : chroma([r, g, b]).hsv()[0],
      s: chroma([r, g, b]).hsv()[1],
      v: chroma([r, g, b]).hsv()[2],
    }
  }

  const getColorPickerStyle = () => {
    const rowColor: number[] = colorMapRow.color
    const r = rowColor[0]
    const g = rowColor[1]
    const b = rowColor[2]
    const a = rowColor[3]
    const rgba = `rgba(${r}, ${g}, ${b}, ${a})`
    colorPickerStyle = `caret-color:${rgba}; background-color: ${rgba}`
    return colorPickerStyle
  }

  $: isVisible, handleVisibilityChanged()
  const handleVisibilityChanged = () => {
    if (isVisible) {
      color.a = 1
    } else [(color.a = 0)]
    updateColorMap(color)
  }

  // set color of display and dispatch to update map
  const updateColorMap = (colorSelected: Color) => {
    if (colorSelected) {
      try {
        // let rgba: number[] = chroma(colorSelected['hex']).rgba()
        const { r, g, b, a } = colorSelected
        let rgba: number[] = [r, g, b, a]

        /*the fix below is necessary becuse the Color picker has some rounding errors generated by
          computing the position of the color selector in percentages and emits an incredible number of events
          which make the color returned change slightly on multiple consecutive invocations without touching the selector
          for example and this triggers map rerendering in vain
          The solutin is to detect changes for every dimension of the color, sum the differences and only
          update the map on a consistent color change (larger delta)


        */

        // const delta = rgba.map((el, i) => abs(el - colorMapRow.color[i])).reduce((a, b) => a + b, 0)
        colorMapRow.color = rgba
        colorPickerStyle = getColorPickerStyle()
        dispatch('changeColorMap', {
          color,
        })
      } catch (e) {
        console.log(e)
      }
    }
  }

  const handleColorChanged = () => {
    colorMapRow.color = [color.r, color.g, color.b, color.a]
    colorPickerStyle = getColorPickerStyle()
    updateColorMap(color)
    dispatch('changeColorMap', {
      color,
    })
  }

  const handleInput = (e) => {
    const id = e.target.id
    const value = (e.target as HTMLInputElement).value
    signal = value
    dispatch('changeIntervalValues', {
      index: colorMapRow.index,
      id,
      value: parseFloat(value),
    })
  }

  const handleEnterKey = (e: { key: string; target: { click: () => void } }) => {
    if (e.key === 'Enter') {
      e.target.click()
    }
  }
</script>

<!--
the key statement is necessary as it forces to rerender the legend item in case an invalid valus is provided
-->
{#key signal}
  <div class="columns is-mobile p-0 m-0 py-1">
    <div class="column is-1 p-0 m-0">
      <div
        role="button"
        class="visible-button icon"
        on:click={() => (isVisible = !isVisible)}
        on:keydown={handleEnterKey}>
        {#if isVisible}
          <i class="fa-solid fa-eye" />
        {:else}
          <i class="fa-solid fa-eye-slash" />
        {/if}
      </div>
    </div>
    <div class="column is-2 p-0 m-0">
      <!-- svelte-ignore a11y-click-events-have-key-events -->
      <div
        title="Color Map Control"
        use:popperRef
        on:click={() => (showToolTip = !showToolTip)}
        class="discrete"
        style="{colorPickerStyle}; width:20px; height:20px" />
      {#if showToolTip && color}
        <div
          id="tooltip"
          data-testid="tooltip"
          use:popperContent={popperOptions}
          use:clickOutside={() => (showToolTip = false)}
          transition:fade>
          <ColorPicker
            bind:color
            on:changeColor={handleColorChanged}
            on:closeColorPicker={() => (showToolTip = false)} />
          <div
            id="arrow"
            data-popper-arrow />
        </div>
      {/if}
    </div>
    <div class="column p-0 m-0">
      <input
        style="width:{rowWidth * 8}px; max-width:100px"
        class="number-input"
        id="start"
        type="number"
        value={colorMapRow.start}
        on:change={handleInput}
        required />
    </div>
    {#if colorMapRow.end}
      <div class="is-3 column p-0 m-0"><p style="margin-left: {rowWidth + 5}px">â€”</p></div>
      <div class="column p-0 m-0">
        <input
          style="width:{rowWidth * 8}px; max-width:100px"
          class="number-input"
          type="number"
          id="end"
          value={colorMapRow.end}
          on:change={handleInput}
          required />
      </div>
    {/if}
  </div>
{/key}

<style lang="scss">
  @import '../../styles/popper.scss';

  $input-margin: 5px !important;

  .visible-button {
    cursor: pointer;
  }

  .number-input {
    width: 100%;
    text-align: left;
    border: none;
    background-color: transparent;
  }

  .discrete {
    cursor: pointer !important;
    height: 20px;
    width: 20px;
    border: 1px solid gray;
  }

  :global(.discrete):hover {
    padding: 0;
    border: 2px solid rgb(0, 0, 0);
  }

  input:focus {
    outline: none;
    background: rgb(220, 220, 220, 0.3);
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input[type='number'] {
    -moz-appearance: textfield;
  }

  #tooltip {
    height: 280px;
    padding: 0;
    width: 290px;
    max-width: 290px;
  }
</style>
