<script lang="ts">
	import Tags from '$components/pages/map/layers/vector/Tags.svelte';
	import { getLayerStyle } from '$lib/helper';
	import type { Layer } from '$lib/types';
	import {
		MAPSTORE_CONTEXT_KEY,
		Slider,
		type MapStore,
		type VectorLayerTileStatAttribute,
		type VectorTileMetadata
	} from '@undp-data/svelte-undp-components';
	import arraystat from 'arraystat';
	import type { Listener, MapMouseEvent, SymbolLayerSpecification } from 'maplibre-gl';
	import { createEventDispatcher, getContext, onDestroy } from 'svelte';
	import { FILTER_INPUTTAGS_CONTEXT_KEY, type FilterInputTags } from './VectorFilter.svelte';

	const map: MapStore = getContext(MAPSTORE_CONTEXT_KEY);

	const filterInputTags: FilterInputTags = getContext(FILTER_INPUTTAGS_CONTEXT_KEY);

	export let propertySelectedValue: string;
	export let expressionValue: number[];
	export let acceptSingleTag = true;
	export let layer: Layer;
	export let operator:
		| '>'
		| '<'
		| '>='
		| '<='
		| '=='
		| '!='
		| 'in'
		| '!in'
		| 'has'
		| '!has'
		| 'all'
		| 'none'
		| 'any';

	const layerStyle = getLayerStyle($map, layer.id);
	const metadata = layer.info as VectorTileMetadata;
	const tilestatLayer = metadata.json.tilestats.layers.find(
		(l) => l.layer === layerStyle['source-layer']
	);
	const propertyProps = tilestatLayer.attributes.find(
		(e) => e['attribute'] === propertySelectedValue
	);
	const dataType = propertyProps['type'];
	let warningSingleTagEqual = false;
	let badSingleTagValue;

	const layerId = layer.id;

	const attrstats = tilestatLayer.attributes.filter((el: VectorLayerTileStatAttribute) => {
		return el.attribute == propertySelectedValue;
	})[0];

	if (!attrstats) {
		//this should not happen, however....it could so a recation must be set (error)
		console.log('unexpected situation');
	}

	const hasManyFeatures = attrstats.count > 250;

	const dispatch = createEventDispatcher();

	let hideOptions = true;
	let uv: string[] = undefined;
	let clickFuncs: Listener[] = [];
	let cursor: string;
	let mapClickButtonDisabled = false;
	let sv: Array<number> = [];
	let calculatedStep: number;
	let min: number;
	let max: number;
	let vals: Array<number> = [];
	let svals: Array<number> = [];

	let sindex: number;
	let eindex: number;
	let closest: number;
	let index: number;
	let sol: [];
	const nn = 5;
	$: tagsList = $filterInputTags;

	const fclosest = (array, goal) =>
		array.reduce((prev, curr) => (Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev));

	if (hasManyFeatures) {
		const values = attrstats.values?.map((v) => (typeof v === 'string' ? Number(v) : v));
		const stats = values ? arraystat(values) : undefined;
		min = attrstats?.min ? Number(attrstats.min) : stats.min;
		max = attrstats?.max ? Number(attrstats.max) : stats.max;
		const range = max - min;
		calculatedStep =
			Number.isInteger(attrstats.median) && Number.isInteger(min)
				? ~~(range * 1e-4) || 1
				: range * 1e-4;

		sv = attrstats?.median ? [attrstats.median] : [stats.median];
	} else {
		let features = $map.querySourceFeatures({ layers: [layerId] });

		if (features.length == 0) {
			const layerStyle = getLayerStyle($map, layer.id);
			features = $map.querySourceFeatures(layerStyle.source, {
				sourceLayer: layerStyle['source-layer'],
				filter: undefined
			});
		}

		// get the values of the property for each feature
		const values = features
			.filter((f) => f.properties[propertySelectedValue] != undefined)
			.map((feature) => feature.properties[propertySelectedValue]);

		let optionsList: number[] = [...new Set(values.flat())];
		sol = Array.from(optionsList).sort((a, b) => a - b);

		if (!['string', 'mixed'].includes(dataType)) {
			const astats = arraystat(sol);
			min = astats.min;
			max = astats.max;
			//                                        negative               0->1
			calculatedStep = Number.isInteger(min) ? ~~(astats.range * 1e-2) || 1 : astats.range * 1e-2;
			let closest = fclosest(sol, astats.median);
			sv = [closest];

			index = sol.indexOf(closest);
			sindex = index - nn < 0 ? 0 : index - nn;
			eindex = index + nn > sol.length - 1 ? sol.length : index + nn;
			vals = sol.slice(sindex, eindex);
			svals = vals.sort();
		}
	}

	$: {
		if (!hasManyFeatures && !['string', 'mixed'].includes(dataType)) {
			closest = fclosest(sol, sv[0]);
			index = sol.indexOf(closest);
			sindex = index - nn < 0 ? 0 : index - nn;
			eindex = index + nn > sol.length - 1 ? sol.length : index + nn;
			vals = sol.slice(sindex, eindex);
			svals = vals.sort();
		}
	}

	const onSliderStop = (event: CustomEvent) => {
		expressionValue = event.detail.values;
		dispatch('sliderStop', event.detail);
	};

	onDestroy(() => {
		restoreQ();
	});

	const handleTags = (event: CustomEvent) => {
		//console.log('CE')
		if (warningSingleTagEqual) {
			warningSingleTagEqual = !warningSingleTagEqual; //reset
			//tagsList = []
			badSingleTagValue = null;
		}

		if (acceptSingleTag) {
			if (sol.includes(event.detail.tags[0])) {
				tagsList = event.detail.tags;
			} else {
				tagsList = [];
				badSingleTagValue = event.detail.tags[0];
				warningSingleTagEqual = !warningSingleTagEqual; //set
			}
		} else {
			tagsList = event.detail.tags;
		}
	};

	const applyTags = () => {
		const filteredTags = tagsList.filter((tag) => !sol.includes(tag));
		$filterInputTags = [...$filterInputTags, ...filteredTags];
		if (filteredTags.length > 0) {
			dispatch('customTags', tagsList);
		} else {
			expressionValue = tagsList;
		}

		dispatch('apply');
	};

	const apply = () => {
		if (!expressionValue) expressionValue = sv[0];
		tagsList = [];
		clearClickLayer();
		dispatch('apply');
	};

	const clearClickLayer = () => {
		if (layer.children?.length > 0) {
			const child = layer.children.find((l) => l.id === `${layerId}-select`);
			if (child) {
				if ($map.getLayer(child.id)) {
					$map.removeLayer(child.id);
				}
				layer.children.splice(layer.children.indexOf(child), 1);
			}
		}
	};

	const handleMapClick = async (e: MapMouseEvent) => {
		try {
			if (e.features) {
				const features = e.features;

				const selectedValue = features[0].properties[propertySelectedValue];
				if (selectedValue) {
					if (operator.includes('in')) {
						if (Array.isArray(uv)) {
							uv = [...uv, selectedValue];
						} else {
							uv = [selectedValue];
						}
					} else {
						uv = selectedValue;
					}
				}
			}
		} catch (error) {
			console.log(`got err ${error}`);
		}
	};

	const getFromMap = async () => {
		mapClickButtonDisabled = !mapClickButtonDisabled;
		cursor = $map.getCanvas().style.cursor;
		$map.getCanvas().style.cursor = 'cell';
		if (clickFuncs.length == 0) {
			clickFuncs = [...$map._listeners.click];
		}
		for (var func of clickFuncs) {
			$map.off('click', func);
		}

		const layerStyle = getLayerStyle($map, layerId);
		if (layerStyle.type === 'heatmap') {
			const clickLayerId = `${layerId}-select`;
			const clickLayer: SymbolLayerSpecification = {
				id: clickLayerId,
				type: 'symbol',
				source: layerStyle.source,
				'source-layer': layerStyle['source-layer'],
				layout: {
					visibility: 'visible',
					'icon-image': 'circle',
					'icon-size': 1
				},
				paint: {
					'icon-color': '#000000'
				}
			};
			if (!$map.getLayer(clickLayerId)) {
				$map.addLayer(clickLayer);
				if (!layer.children) {
					layer.children = [];
				}
				layer.children = [
					...layer.children,
					{
						id: clickLayerId,
						name: 'select-feature',
						info: layer.info,
						parentId: layerId,
						dataset: undefined
					}
				];
			}
			$map.on('click', clickLayerId, handleMapClick);
		} else {
			$map.on('click', layerId, handleMapClick);
		}
	};

	const restoreQ = () => {
		mapClickButtonDisabled = !mapClickButtonDisabled;
		$map.off('click', layerId, handleMapClick);
		for (var func of clickFuncs) {
			$map.on('click', func);
		}
		$map.getCanvas().style.cursor = cursor;
	};
</script>

<div class="content" style="width:100%; height:100%">
	{#if hasManyFeatures}
		{#if ['string', 'mixed'].includes(dataType)}
			<div class="columns is-centered pb-2">
				<button
					class="button is-small is-uppercase has-text-weight-bold is-link"
					on:click={getFromMap}
					disabled={mapClickButtonDisabled}
				>
					Select from map
				</button>
			</div>
			{#if uv}
				<div class="is-flex is-flex-direction-column is-align-items-center is-justify-items-center">
					<div class="notification is-size-6 has-text-centered">
						Selected value: <span class="has-text-weight-bold"> {uv} </span>
					</div>
					<div class=" ">
						<button
							class="button is-small is-uppercase has-text-weight-bold is-link"
							on:click={() => {
								expressionValue = Array.isArray(uv) ? uv : [uv];
								apply();
								restoreQ();
							}}
						>
							Apply
						</button>
					</div>
				</div>
			{/if}
		{:else}
			<!-- Numeric many values-->
			<!-- Numeric, many features few UV could be handled specially-->
			{#if ['<', '>'].includes(operator)}
				<Slider
					bind:values={sv}
					{min}
					{max}
					step={calculatedStep}
					range="min"
					first="label"
					last="label"
					rest={false}
					on:change={onSliderStop}
				/>
				<div class="columns is-centered pb-2">
					<button
						class="button is-small is-uppercase has-text-weight-bold is-link"
						on:click={apply}
					>
						Apply</button
					>
				</div>
			{:else}
				<div class="columns is-centered pb-2">
					<button
						class="button is-small is-uppercase has-text-weight-bold is-link"
						on:click={getFromMap}
						disabled={mapClickButtonDisabled}
					>
						Select from map
					</button>
				</div>
				{#if uv}
					<div
						class="is-flex is-flex-direction-column is-align-items-center is-justify-items-center"
					>
						<div class="notification is-size-6 has-text-centered">
							{#if typeof uv === 'number'}
								Selected value: <span class="has-text-weight-bold">
									{new Intl.NumberFormat('en-IN', { maximumSignificantDigits: 3 }).format(uv)}
								</span>
							{:else}
								Selected value: <span class="has-text-weight-bold"> {uv} </span>
							{/if}
						</div>
						<div class=" ">
							<button
								class="button is-small is-uppercase has-text-weight-bold is-link"
								on:click={() => {
									expressionValue = uv;
									apply();
									restoreQ();
								}}
							>
								Apply
							</button>
						</div>
					</div>
				{/if}
			{/if}
		{/if}
	{:else}
		<!--FEW features-->

		{#if ['string', 'mixed'].includes(dataType)}
			<div>
				{#if acceptSingleTag}
					{#if warningSingleTagEqual}
						<div class="notification has-background-danger-light is-size-6 has-text-danger">
							<i class="fa-solid fa-circle-info has-text-danger"></i>
							<span class="subtitle has-text-weight-bold">{badSingleTagValue}</span>
							does not exist in
							<span class="has-text-weight-bold message is-primary p-2"
								>{propertySelectedValue}</span
							>
							property
						</div>
					{:else}
						<div class="notification has-background-danger-light is-size-6 has-text-danger">
							<i class="fa-solid fa-circle-info has-text-danger"></i>
							Only one value can be accepted when equals = or ≠ operators are used
						</div>
					{/if}
				{/if}

				<Tags
					on:tags={handleTags}
					maxTags={acceptSingleTag ? 1 : 100}
					addKeys={[9, 13]}
					splitWith={'/'}
					onlyUnique={true}
					removeKeys={[27]}
					placeholder={'Select a value...'}
					autoComplete={sol}
					tags={tagsList}
					allowBlur={true}
					disable={acceptSingleTag && tagsList.length > 0}
					minChars={0}
					onlyAutocomplete={false}
					labelShow={false}
					{hideOptions}
				/>
				<div
					class="pt-4 is-flex flex-wrap is-flex-direction-columns is-justify-content-space-between is-rounded"
				>
					<div>
						<button
							disabled={tagsList.length === 0}
							class="button is-small is-uppercase has-text-weight-bold is-link"
							on:click={applyTags}
						>
							Apply
						</button>
					</div>
				</div>
			</div>
		{:else}
			<!--Numeric property-->
			{#if !['<', '>'].includes(operator)}
				<!--<> operators use slider-->

				<Slider
					bind:values={sv}
					{min}
					{max}
					step={calculatedStep}
					range="min"
					first="label"
					last="label"
					rest={false}
				/>

				<div class="buttons">
					{#each svals as v}
						<button
							on:click={(e) => {
								expressionValue = v;
								apply(e);
							}}
							class="button has-background-info-light"
						>
							{v}
						</button>
					{/each}
				</div>
			{:else}
				<Slider
					bind:values={sv}
					{min}
					{max}
					step={calculatedStep}
					range="min"
					first="label"
					last="label"
					rest={false}
					on:change={onSliderStop}
				/>
				<div class="columns is-centered pb-2">
					<button
						class="button is-small is-uppercase has-text-weight-bold is-link"
						on:click={apply}
					>
						Apply
					</button>
				</div>
			{/if}
		{/if}
	{/if}
</div>
